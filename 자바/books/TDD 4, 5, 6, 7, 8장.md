# 4장. 프라이버시



이전 챕터에서 동치성 문제를 정의 했습니다. 개념적으로 Dollar.times() 연산은 호출을 받은 객체의 값에 인자로 받은 곱수만큼 곱한 값을 갖는 Dollar를 반환 해야 합니다. 



```java
public void testMultiplication(){
    Dollar five = new Dollar(5); // five == 5달러
    Dollar product = five.times(2); // product = 10달러
    assertEquals(10, product); // 10와 product 비교
    product = five.times(3); // product = 15달러
    assertEquals(15, product.amount); // 15와 product 비교
}
```

처음엔 테스트 케이스를 이렇게 작성 할 수 있지만

1.  첫 번째 assertion 을 Dollar 와 Dollar를 비교할 수 있도록 재작성 할 수 있다.

   ```java
   assertEquals(new Dollar(10), product);
   ```

2.  두 번째 assertion도 마찬가지로 고칠 수 있다.

   ```java
   assertEquals(new Dollar(15), product);
   ```

3. 이제 임시 변수인 product는 더 이상 쓸모 없어 보인다. 인라인 시켜보자

   ```java
   public void testMultiplication() {
       DOllar five = new Dollar(5);
       assertEquals(new Dollar(10), five.times(2));
       assertEquals(new Dollar(15), five.times(3));
   }
   ```

4. 테스트를 고치고 나니 이제 Dollar 의 amount 인스턴스 변수를 사용하는 코드는 Dollar 자신밖에 없게 됐다. 따라서 변수를 private으로 변경 할 수 있다.

   ```java
   Dollar
   private int amount;
   ```

5.  할일을 줄였지만 위험한 상황을 만들었다는 점에 주목하자.

   - 만약 동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증 하는 데 실패한다면, 곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는 데 실패하게 된다.
   - 완벽함을 위해 노력하지는 않지만 모든 것을 두번 말함으로써(코드와 테스트로 한번씩) 자신감을 가지고 전진할 수 있을 만큼만 결함의 정도를 낮추기를 희망할 뿐이다.
   - 두 테스트가 동시에 실패하면 망한다.
   - 위험요소가 있음에도 계속 진행했다.





# 5장. 솔직히 말하자면



```java
$5 + 10CHF = $10(환율이 2:1 일 경우)
```

가장 흥미로워 보이는 테스트에 접근해보자 일단 작은 단계부터 접근해보자



먼저 Dollar 테스트를 복사한 후에 Franc 객체를 만들어보자

```java
public void testFrancMultiplication() {
    Franc five = new Franc(5);
    assertEquals(new Franc(10), five.times(2));
    assertEquals(new Franc(15), five.times(3));
}
```



다시 상기시켜보면 테스트를 하기 위해 5개의 단계로 진행한다.

1.  테스트 작성.
2. 컴파일되게 하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복제거.

각 단계는 서로 다른 목적이 있고 다른 스타일의 해법, 다른 미적 시각을 필요로 한다.

처음 네 단계를 빨리 진행해야 한다. 그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다.

거기에 도달하기 위해선 어떤 죄도 저지를 수 있다.

하지만 중요한 것은 **5번째 단계**이다. 다섯번째 단계 없이는 앞의 네 단계도 제대로 되지 않는다. **올바르게 만들어라**



```java
//Franc
class Franc{
    private int amount;
    
    Franc(int amount) {
        this.amount = amount;
    }
    
    Franc times(int multiplier) {
        return new Franc(amount * multiplier);
    }
    
    public boolean equals(Object object) {
        Franc franc = (Franc) Object;
        return amount == franc.amount;
    }
}
```



코드를 실행시키기까지의 단계가 짧았기 때문에 '컴파일되게 하기 ' 단계도 넘어갈 수 있었다.

중복이 엄청나게 많기 때문에 다음 테스트를 작성하기 전에 이것들을 제거 해야된다. equals()를 일반화하는 것부터 시작하자

1. 큰 테스트를 공략할 수 없다. 그래서 진전을 나타낼 수 있는 자그마한 테스트를 만들었다.
2. 뻔뻔하게도 중복을 만들고 조금 고쳐서 테스트를 작성했다.
3. 설상가상으로 모델 코드까지 복사해서 수정을 약간 한 후 테스트를 통과했다.
4. 중복이 사라지기 전에는 집에 가지 않겠다고 약속했다.





# 6장. 돌아온 '모두를 위한 평등'



이제 코드를 청소할 시간이다. 상속은 좋은 방법이 되지 못한다. 대신 두 클래스의 공통 상위 클래스를 찾아낼 생각이다.

먼저 Dollar와 Franc의 공통의 상위 클래스인 Money를 만듭니다.

Money 클래스가 공퉁의 equals 코드를 갖게 하면 어떨까요? 간단한 것 부터 시작해봅시다.

```java
class Money {
    protected int amount; //먼저 amount 인스턴스 변수를 Money로 옮긴다.
}
```

```java
class Dollar extends Money {
    // Money의 상속을 받고 amount 인스턴스 제거
}
```

하위 클래스에서도 변수를 볼 수 있도록 가시성을 private 에서 protected로 변경했다. (천천히 진행하길 원했다면 첫 단계에서 Money에 필드를 선언하고, 다음 단계에서 Dollar의 필드를 제거하는 식으로 했을 수도 있다.)

이제 equals() 코드를 위로 올리는 일을 할 수 있게 됐다. 우선 임시 변수를 선언하는 부분을 변경하자.

```java
class Dollar extends Money{
    public boolean equals(Object object) {
        Money dollar = (Dollar) object; // 임시 변수 형변환 Dollar -> Money
        return amount == dollar.amount;
    }
}
```

다음으로 임시변수의 이름과 캐스트 부분을 바꿔보자

```java
class Dollar extends Money{
    public boolean equals(Object object) {
        Money money = (Money) object;
        return amount == money.amount;
    }
}
```

이제 이 메서드를 Dollar에서 Money로 옮길 수 있다.

```java
class Money{
    protected int amount;
    
    public boolean equals(Object object) {
        Money money = (Money) object;
        return amount == money.amount;
    }
}
```



이제는 Franc.equals() 를 제거해야 한다. 충분한 테스트가 없다면 지원 테스트가 갖춰지지 않은 리펙토링을 만나게 될 수 밖에 없다. 리펙토링 하면서 실수 했는데도 불구하고 테스트가 여전히 통과할 수도 있는 것이다.

있으면 좋을 것 같은 테스트를 작성하라. 그렇게 하지 않으면 결국에는 리팩토링을 하다가 뭔가 깨트릴 것이다. 그러면 여러분은 리팩토링에 대해 안 좋은 느낌을 갖게 되고, 리펙토링을 덜 하게 된다.

Dollar와 테스트를 작성해야 되는 부분이 같으므로 Dollar 테스트를 복사해보자

```java
public void testEquality() {
    assertTrue(new Dollar(5).equals(new Dollar(5)));
    assertFalse(new Dollar(5).equals(new Dollar(6)));
    assertTrue(new Franc(5).equals(new Franc(5)));
    assertFalse(new Franc(5).equals(new Franc(6)));
}
```

이렇게 테스트코드를 짜놓고 Frac 클래스를 리팩토링 해보자

리팩토링 과정은 위에 Dollar의 경우와 기능, 변수등이 동일 하므로 동일하게 진행한다.

```java
class Franc extends Money {
    // Money 클래스에 amount가 있으므로 제거 가능
    
    // equals는 Money.equals 와 거의 비슷하므로 Frac의 equals를 Money의 equals와 똑같이 만들자
    public boolean equals(Object object) {
        Money money = (Money) object;
        return amount == money.amount;
    }
}// 이제 equals 코드를 Franc에서 제거 할 수 있다.
```

지금까지 한 작업을 검토해 보면

1. 공통된 코드를 첫 번째 클래스(Doller)에서 상위 클래스 (Money)로 단계적으로 옮겼다.
2. 두 번째 클래스(Franc) 도 Money의 하위 클래스로 만들었다.
3. 불필요한 구현을 제거하기 전에 두 equals() 구현을 일치시켰다.







# 7장. 사과와 오렌지

영어 속담에 "You can't compare apples and oranges"란 말이 있다. 서로 다른걸 비교할 수 없다는 뜻이다.



문득 떠오른생각에 대해 얘기해 보자. Franc 과 Dollar를 비교하면 어떻게 될까? 

```java
 public void testEquality() {
        assertTrue(new Dollar(5).equals(new Dollar(5)));
        assertFalse(new Dollar(5).equals(new Dollar(6)));
        assertTrue(new Franc(5).equals(new Franc(5)));
        assertFalse(new Franc(5).equals(new Franc(6)));
        assertFalse(new Franc(5).equals(new Dollar(5))); // 실패
    }
```

원래는 Dollar와 Franc은 달라야 하는데 같다고 나와서 실패했다.

동치성 코드에서는 Dollar가 Franc과 비교되지 않는지 검사해야 한다. 두 객체의 클래스를 비교함으로써 이러한 검사를 쉽게 수행할 수 있다. 오직 금액과 클래스가 서로 동일 할 때만 두 Money가 같은 것이다.

```java
public boolean equals(Object object) {
        Money money = (Money) object;
        return amount == money.amount && getClass().equals(money.getClass());
    }
```

모델 코드에서 클래스를 이런 식으로 사용하는 것은 좀 지저분해 보였다. 하지만 현재 통화 개념 같은 게 없고, 통화 개념을 도입할 충분한 이유가 없어 보이므로 잠시 동안은 이대로 두자

이번장에서는

1. 우릴 괴롭히던 결함을 끄집어 내서 테스트에 담아냈다.
2. 완벽하진 않지만 그럭저럭 봐줄 만한 방법 (getClass())으로 테스트를 통과하게 만들었다.
3. 더 많은 동기가 있기 전에는 더 많은 설계를 도입하지 않기로 했다.





# 8장. 객체 만들기

두 times() 구현 코드가 거의 똑같다.

```java
    Franc times(int multiplier) {
        return new Franc(amount * multiplier);
    }

    Dollar times(int multiplier) {
        return new Dollar(amount * multiplier);
    }

```

양쪽 모두 Money를 반환하게 만들면 더 비슷하게 만들수 있다.

```java
  Money times(int multiplier) {
        return new Franc(amount * multiplier);
    }

    Money times(int multiplier) {
        return new Dollar(amount * multiplier);
    }

```

Money의 두 하위 클래스는 그다지 많은 일을 하는 것 같지 않으므로 아예 제거해버리고 싶다.

그런데 한꺼번에 큰 단계를 밟는 것은 TDD를 효과적으로 보여주기에 적절하지 않을 것 같다.

하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있겠다. Money에 Dollar를 반환하는 팩토리 메서드를 도입할 수 있다.

<a href="https://johngrib.github.io/wiki/factory-method-pattern/">팩토리메서드 참조</a>

```java
public void testMuliplication(){
    Dollar five = Money.dollar(5);
    assertEquals(new Dollar(10), five.times(2));
    assertEquals(new Dollar(15), five.times(3));
}
```

구현 코드는 Dollar를 생성하여 반환한다.

```java
static Dollar dollar(int amount) {
    return new Dollar(amount);
}
```

Dollar에 대한 참조가 사라지길 바라므로 테스트의 선언부를 다음과 같이 바꿔야 한다.

```java
public void testMuliplication(){
    Money five = Money.dollar(5);
    assertEquals(new Dollar(10), five.times(2));
    assertEquals(new Dollar(15), five.times(3));
}
```

컴파일러가 Money에는 times()가 정의되지 않았다는 사실을 알려준다.

지금은 그것을 구현할 준비가 되지 않았기 때문에 Money를 추상 클래스로 변경한 후 Money.times()를 선언하자.

```java
abstract class Money
abstract Money times(int multiplier)
```

이제 팩토리 메서드의 선언을 바꿀 수 있다.

```java
Money
static Money dollar(int amount) {
    return new Dollar(amount);
}
```

이제 이 팩토리 메서드를 테스트 코드의 나머지 모든 곳에서 사용할 수 있다.

```java
public void testMultiplication() {
    Money five = Money.dollar(5);
    assertEquals(Money.dollar(10), five.times(2));
    assertEquals(Money.dollar(15), five.times(3));
    
}

  public void testEquality() {
        assertTrue(Money.dollar(5).equals(Money.dollar(5)));
        assertFalse(Money.dollar(5).equals(Money.dollar(6)));
        assertTrue(new Franc(5).equals(new Franc(5)));
        assertFalse(new Franc(5).equals(new Franc(6)));
        assertFalse(new Franc(5).equals(Money.dollar(5)));
    }

```

이제 전보다 조금 나은 상황이다. 어떤 클라이언트 코드도 Dollar라는 이름의 하위 클래스가 있다는 사실을 알지 못한다. 하위 클래스의 존재를 테스트에서 분리함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 됐다.

Franc 도 똑같이 바꿔주자. 구현은 Money.dollar와 유사하다.

```java
static Money1 franc(int amount) { 
    return  new Franc1(amount);
} 

public void testEquality() {
        assertTrue(Money1.dollar(5).equals(Money1.dollar(5)));
        assertFalse(Money1.dollar(5).equals(Money1.dollar(6)));
        assertTrue(Money1.franc(5).equals(Money1.franc(5)));
        assertFalse(Money1.franc(5).equals(Money1.franc(6)));
        assertFalse(Money1.franc(5).equals(Money1.dollar(5)));
    }

 public void francTestMultiplication() {
        Money1 five = Money1.franc(5);
        assertEquals(Money1.franc(10), five.times(2));
        assertEquals(Money1.franc(15), five.times(3));

    }
```

다음 장에서 우리는 times() 중복을 거둬낼 것이다. 하지만 일단 검토해 보자 우리는

1. 동일한 메서드(times)의 두 변이형 메서드 서명부를 통일시킴으로써 중복 제거를 향해 한 단계 전진했다.
2. 최소한 메서드 선언부만이라도 공통 상위 클래스로 옮겼다.
3. 팩토리 메서드를 도입하여 테스트 코드에서 콘크리트 하위 클래스의 존재 사실을 분리해냈다.
4. 하위 클래스가 사라지면 몇몇 테스트는 불필요한 여분의 것이 된다는 것을 인식했다. 하지만 일단 그냥 뒀다.