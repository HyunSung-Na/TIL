---

### Clean Code 11장 시스템

---

**시스템 제작과 시스템 사용을 분리하라**

소프트웨어 시스템은 준비과정과 런타임 로직을 분리해야

초기화 지연 (Lazy Initialization) 또는 계산 지연 (Lazy Evalutaion) 기법



**Main 분리**

시스템 제작과 시스템 사용을 분리하는 방법 중 한가지

생성관련 코드는 모두 main 이나 main 이 호출하는 모듈을 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정



**팩토리**

객체가 생성되는 시점을 애플리케이션이 결정해야 할 경우

팩토리를 구현하여 애플리케이션으로 넘겨준다



**의존성 분리**

사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입 (Dependecy Injection)

의존성 주입하는 방법으로 setter 메서드 또는 생성자 인수를 제공

실제로 생성되는 객체 유형은 설정파일에서 지정하거나 특수 생성 모듈에서 코드로 명시



**확장**

'처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스터리에 맞춰 시스템을 구현해야한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.

반복적이고 점진적인 애자일 방식의 핵심!

관심사를 적절하게 분리하여 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.



**테스트 주도 시스템 아키텍처 구축**

아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장한다



**의사결정을 최적화하라**

모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.

최대한의 정보를 모아 최선의 결정을 내리기 위해서 가능한 마지막 순간까지 결정을 미루는 방법



**명백한 가치가 있을 때 표준을 현명하게 사용하라**

표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화 하기 쉽고, 컴포넌트를 엮기 쉽다

하지만, 때로는 표준을 만드는 시간을 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다



**시스템은 도메인 특화 언어가 필요하다**

도메인 특화 언어를 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.



**결론**

시스템은 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 

모든 추상화 단계에서 의도는 명확히 표현. 그러기 위해서는 POJO 를 작성하고 관점 혹은 관점과 유사한 메커니즘을 이용해 각 구현 관심사 분리

시스템 설계하든 개별 모듈을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용해야 한다





---

### Clean Code 12장 창발성

---

**창발적 설계로 코드를 구현하자**

켄트 벡이 제시하는 '단순한 설계'

1. 모든 테스트를 실행한다
   - 테스트가 불가능한 시스템은 검증도 불가능하다. 검증이 불가능한 시스템은 절대 출시하면 안됀다.
2. 중복을 없앤다
   - 비슷한 코드는 더 비슷하게 고쳐주면 리펙터링이 쉬워진다
   - 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다
3. 프로그래머 의도를 표현한다
   - 좋은 이름을 선택한다
   - 함수와 클래스 크기를 가능한 줄인다
   - 표준 명칭을 사용한다
   - 단위 테스트 케이스를 꼼꼼히 작성한다
4. 클래스와 메서드 수를 최소로 줄인다
   - 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다





---

### Clean Code 13장 동시성

---

**동시성이 필요한 이유**

동시성은 결함을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략

구조적인 관점에서 프로그램은 거대한 루프가 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기 쉽고 문제를 분리하기도 쉽다

동시성이 반드시 필요한 상황이 존재하고 장점이 있지만,

동시성은 다소 부하를 유발하고, 복잡하고, 버그 재현이 어렵다. 또한 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.



**동시성 방어 원칙**

단일 책임 원칙 (Single Resposibility Principle)

주어진 메서드, 클래스, 컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다. 동시성은 복잡성 하나만으로 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다.



자료 범위를 제한하라

공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라고 권장한다. 이런 임계영역의 수를 줄이는 기술이 중요하다. 공유 자료룰 수정하는 위치가 많을 수록 보호할 임계영역을 빼먹을 가능성이 커지고 모든 임계영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복하게 되는 단점이 생긴다.



자료 사본을 사용하라

공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.

어떤 경우에는 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다



스레드는 가능한 독립적으로 구현하라

다른 스레드와 자료를 공유하지 않는다.

독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다



라이브러리를 이해하라

언어가 제공하는 클래스를 검토하라.

자바에서는

```
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
```



**실행 모델을 이해하라**

생산자와 소비자

생산자 스레드와 소비자 스레드가 둘다 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성 존재



읽기 쓰기

읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다



식사하는 철학자들

각 알고리즘을 공부하고 해법을 직접 구현해보라. 실전 문제에 부닥쳤을 때 해결이 쉬워진다.



**동기화하는 메서드 사이에 존재하는 의존성을 이해하라**

동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.

공유 객체 하나에는 메서드 하나만 사용하라.



**동기화 하는 부분을 작게 만들어라**

코드를 짤 때, 임계영역 수를 최대한 줄인다. 하지만, 필요 이상으로 줄이면 임계영역 크기가 커지고 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.



**올바른 종료 코드는 구현하기 어렵다**

가장 흔하게 발생하는 무넺는 데드락이다. 즉, 스레드가 절대 오지 않는 시그널을 기다린다.

종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라



**스레드 코드 테스트하기**

말이 안되는 실패는 잠정적인 스레드 문제로 취급하라

- 시스템 실패를 '일회성'이라 치부하지 마라.

다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만든다.

- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생긴느 버그를 동시에 디버깅하지 마라.
- 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

다중 스레드를 쓰는부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라

- 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라

프로세서 수보다 많은 스레드를 돌려보라

다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

- 스와핑이 잦을수록 임계영역을 뺴먹은 코드나 데드락을 일으키는코드를 찾기 쉽다

다른 플랫폼에서 돌려보라

- 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

코드에 보조코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

- 직접 구현하기
  - wait(), sleep(), yield(), priority() 함수를 추가한다
- 자동화
  - 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서다. 좋은 테스트 케이스와 흔들기 기법은 오류가 드러날 확률을 크게 높인다.



**결론**

SRP 를 준수한다

사용하는 라이브러리와 기본 알고리즘을 이해한다

보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다

스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트 해야한다



