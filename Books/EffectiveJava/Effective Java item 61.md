# Effective Java item 61



### 박싱된 기본 타입보다는 기본 타입을 사용하라



자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. 바로 int, double, boolean 같은 기본 타입과 String, List 같은 참조 타입이다. 그리고 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.



- 기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다.

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성도 갖는다. 달리 말하면 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 휴효하지 않은 값, 즉 null를 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

🚩 위 세 가지 차이 때문에 주의하지 않고 사용하면 진짜로 문제가 발생할 수 있다.



```java
// 잘못 구현한 비교자 - 문제를 찾아보자!

Comparator<Integer> naturalOrder =
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

별다른문제를 찾기 어렵고, 실제로 이것저것 테스트해봐도 잘 통과한다. 하지만 심각한 결함이 숨어있다.

이 결함을 확인하고 싶다면 naturalOrder 값에  new Integer(42), new Integer(42) 를 넣어보자. 두 값이 같으므로 실제로는 0이 출력해야 하지만, 실제로는 1을 출력한다.

- 이것의 원인은 무엇일까 첫 번째 검사는 잘 작동한다. 하지만 두 번째 검사에서 두 '객체 참조'의 식별성을 검사하게 된다. 서로 객체 참조가 다르기 때문에 false가 되고 1이 출력된다.
- **이처럼 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.**



실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder() 를 사용하자.

```java
// 문제를 수정한 비교자

Comparator<Integer> naturalOrder = ( iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // 오토박싱
    return i < j ? -1 : (i == j ? 0 : 1);
}
```



이제 다음의 간단한 프로그램을 살펴보자.

```java
// 기이하게 동작하는 프로그램 - 결과를 맞혀보자!

public class Unbelievable {
    static Integer i;
    
    public static void main(String[] args) {
        if (i == 42)
            System.out.println("믿을 수 없군!");
    }
}
```

이 프로그램은 "믿을 수 없군!"을 출력하지 않지만 그만큼 기이한 결과를 보여준다. i == 42를 검사할 때 NullPointerException을 던지는 것이다. 원인은 i가 int가 아닌 Integer이며,  다른 참조 타입 필드와 마찬가지로 초깃값이 null이라는 데 있다.

- **기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.** 다행히 해법은 간단하다. i를 int로 선언해주면 끝이다.



이번엔 다른 경우를 살펴보자

```java
// 끔찍이 느리다! 객체가 만들어지는 위치를 찾았는가?

public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    
    System.out.println(sum);
}
```

- 이 프로그램은 실수로 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다. 오류나 경고 없이 컴파일 되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.



🚀 그렇다면 박싱된 기본 타입은 언제 써야 하는가? 적절히 쓰이는 경우가 몇 가지 있다.

1. 컬렉션의 원소, 키, 값으로 쓰인다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다. 더 일반화해 말하면 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본타입을 써야한다.
2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.



> 핵심 정리
>
> 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자. **오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.** 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 여러분이 원한 게 아닐 가능성이 크다. 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, **언박싱 과정에서 NullPointerException을 던질 수 있다.** 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.