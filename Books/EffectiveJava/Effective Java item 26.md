# Effective Java item 26



### 로 타입은 사용하지 말라



클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 **제네릭 클래스** 혹은 **제네릭 인터페이스**라 한다.

예컨대 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다. 그래서 이 인터페이스의 완전한 이름은 List<E>지만, 짧게 그냥 List라고도 자주 쓴다. 제네릭 클래스와 제네릭 인터페이스를 통틀어 **제네릭 타입**이라 한다.



- 각각의 제네릭 타입은 일련의 **매개변수화 타입**을 정의한다. 먼저 클래스 이름이 나오고, 이어서 괄호 안에 실제 타입 변수들을 나열한다.
- 제네릭 타입을 하나 정의하면 그에 딸린 **로 타입**도 함께 정의된다. 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 예컨대 List<E>의 로 타입은 List다. 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.



:notebook_with_decorative_cover: 제네릭을 지원하기 전에는 컬렉션을 다음과 같이 선언했다. 자바 9에서도 여전히 동작하지만 좋은 예라고 볼 순 	없다.

```java
// Stamp 인스턴스만 취급한다.
private final Collection stamps = ...;
```

이 코드를 사용하면 실수로 도장 대신 동전을 넣어도 아무 오류없이 컴파일되고 실행된다(컴파일러가 모호한 경고 메시지를 보여주긴 할 것이다.)



```java
// 실수로 동전을 넣는다.
stamps.add(new Coin(...)); // "unchecked call" 경고를 내뱉는다.
```

컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아채지 못한다.



```java
// 반복자의 로 타입 - 따라 하지 말 것!
for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.next(); // ClassCastException을 던진다.
    stamp.cancel();
}
```



- 제네릭을 활용하면 이 정보가 주석이 아닌 타입 선언 자체에 녹아든다.

```java
// 매개변수화된 컬렉션 타입 - 타입 안정성 확보!
private final Collection<Stamp> stamps = ...;
```

컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.



:notebook_with_decorative_cover: 로 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다. **로 타입을 쓰면 제네릭이 안	겨주는 안전성과 표현력을 모두 잃게 된다.**

- 그렇다면 절대 써서는 안 되는 로 타입을 애초에 왜 만들어놓은 걸까? 바로 호환성 때문이다. 기존 코드를 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했다.



**List 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.**



```java
// 런타임에 실패한다 - unsafeAdd 메서드가 로 타입을 사용
```

