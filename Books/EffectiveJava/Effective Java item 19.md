# Effective Java item 19



### 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라



아이템 18에서는 상속을 염두에 두지 않고 설계했고 상속할 때의 주의점도 문서화해놓지 않은 '외부'클래스를 상속할 때의 위험을 경고했다.

상속을 고려한 설계와 문서화란 정확히 무얼 뜻할까?

우선 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 달리 말하면, **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야 한다.**

- 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
- API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다. 다음은 java.util.AbstractCollection에서 발췌한 예다.

> public boolean remove(Object o) 
>
> 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다.(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 'Object.equals(o, e)가 참인 원소' e가 하나 이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면 true를 반환한다.
>
> Implementation Requirements 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면, UnsupportedOperationException을 던지니 주의하자.



하지만 이런 식은 "좋은 API문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"라는 격언과는 대치되지 않나? 그렇다. 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다. **클래스를 안전하게 상속할 수 있도록 하려면( 상속만 아니었다면 기술하지 않았어야 할 ) 내부 구현 방식을 설명해야만 한다.**



@implSpec 태그는 자바 8에서 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했다. 이 태그가 기본값으로 활성화되어야 바람직하다고 생각하지만 자바 11의 자바독에서도 선택사항으로 남겨져 있다. 이 태그를 활성화하려면 명령줄 매개변수로 -tag "implSpec:a :Implementation Requirements:"를 지정해주면 된다.



- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.** 드물게는 protected 필드로 공개해야 할 수도 있다.



java.util.AbstractList의 removeRange 메서드를 예로 살펴보자.

> protected void removeRange(int fromIndex, int toIndex)
>
> fromIndex(포함)부터 toIndex(미포함)까지의 모든 원소를 이 리스트에서 제거한다.
>
> toIndex 이후의 원소들은 앞으로 (index만큼씩) 당겨진다. 이 호출로 리스트는 'toIndex - fromIndex' 만큼 짧아진다. (toIndex == fromIndex라면 아무런 효과가 없다.)
>
> 이 리스트 혹은 이 리스트의 부분리스트에 정의된 clear 연산이 이 메서드를 호출한다.
>
> 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분 리스트의 clear 연산 성능을 크게 개선할 수 있다.
>
>  Implementation Requirements : 이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다.
>
> **주의 : ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다.**
>
> Parameters:
>
> ​					fromIndex 제거할 첫 원소의 인덱스
>
> ​					toIndex       제거할 마지막 원소의 다음 인덱스



List 구현체의 최종사용자는 removeRange 메서드에 관심이 없다. 그럼에도 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능응로 만들기 쉽게 하기 위해서다. removeRange 메서드가 없다면 하위 클래스에서 clear메서드를 호출하면 제곱에 비례해 성능이 느려지거나 부분 리스트의 매커니즘을 밑바닥부터 새로 구현해야 했을 것이다.



- 그렇다면 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지는 어떻게 결정할까? 안타깝게도 마법은 없다. 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.



**상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 '유일'하다.** 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다. 거꾸로 하위 클래스를 여러개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다. 경험상 이러한 검증에는 하위 클래스 3개 정도가 적당하다. 그리고 이 중 하나 이상은 제 3자가 작성해봐야 한다.



- 널리 쓰일 클래스를 상속용으로 설계한다면 여러분이 문서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다. 이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다. 그러니 **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.**

- 또한 상속하려는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스만 만들어 사용할 프로그래머에게는 필요 없는 군더더기일 뿐이다.

- 상속을 허용하는 클래스가 지켜야 할 제약이 아직 몇 개 남았다. **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.** 이 규칙을 어기면 프로그램이 오동작할 것이다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 이때 그 재젖ㅇ의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다. 다음의 예를 보자

  ```java
  public class Super {
      // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
      public Super() {
          overrideMe();
      }
      
      public void overrideMe() {
      }
  }
  ```

  다음은 하위 클래스의 코드로 overrideMe 메서드를 재정의했다. 상위 클래스의 생성자가 호출해 오동작을 일으키는 바로 그 메서드다.

  ```java
  public final class Sub extends Super {
      
      // 초기화되지 않은 final필드 생성자에서 초기화된다.
      private final Instant instant;
      
      Sub() {
          instant = Instant.now();
      }
      
      // 재정의 가능 메서드, 상위 클래스의 생성자가 호출한다.
      @Override
      public void overrideMe() {
          System.out.println(instant);
      }
      
      public static void main(Stirng[] args) {
          Sub sub = new Sub();
          sub.overrideMe();
      }
  }
  ```

  이 프로그램이 instant를 두 번 출력하리라 기대했겠지만, 첫 번째는 null을 출력한다. 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하기 때문이다. final 필드의 상태가 이 프로그램에서는 두 가지임에 주목하자( 정상이라면 단 하나뿐이어야 한다.)



> private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.



Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다. 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다. 그 클래스를 확장하려는 프로그래머에게 엄청난 부담을 지우기 때문이다.



- clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다( 새로운 객체를 만든다.) **clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**
- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다. private으로 선언한다면 하위클래스에서 무시되기 때문이다.



**클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알았다.** 절대 가볍게 생각하고 정할 문제가 아니다. 추상 클래스나 인터페이스의 골격 구현처럼 상속을 허용하는 게 명백히 정당한 상황이 있고, 불변 클래스처럼 명백히 잘못된 상활이 있다.



- 이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
  - 상속을 금지하는 방법은 두 가지다.
  - 쉬운 방법은 클래스를 final로 선언하는 방법이다.
  - 두번째는 모든 생성자를 private나 package-private으로 선언하고, public 정적 팩토리를 만들어주는 방법이다. 정적 팩토리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 준다.
- 핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현했다면 상속을 금지해도 개발하는 데 아무런 어려움이 없을 것이다. Set, List, map이 좋은 예다.
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 이런 클래스라도 상속을 해야 한다면 합당한 방법이 있다.
  - 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고, 이 사실을 문서로 남기는 것이다. 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하라는 말이다. 이렇게 하면 상속해도 그리 위험하지 않은 클래스를 만들 수 있다.



클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법을 소개한다.

:apple:먼저 각각의 재정의 가능 메서드는 자신의 본문 코드를 private '도우미 메서드'로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.

:banana:그런 다음 재정의 가능 메서드를 호출하는 다른코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다.



> 핵심 정리
>
> 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다. 다른이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않는다면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.