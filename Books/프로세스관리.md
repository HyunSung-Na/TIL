# 5장 프로세스 관리



### 1. 프로세스의 개념

프로세스란 실행 중인 프로그램을 뜻한다. 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 비로소 생명력을 갖는 프로세스가 되며 프로세스는 CPU을 획득해 자신의 코드를 수행하기도 하고, 때로는 CPU를 반환하고 입출력 작업을 수행하기도 한다.

- 프로세스를 이해하기 위해서는 문맥(context) 에 대해 알 필요가 있다. **프로세스의 문맥이란 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미한다.**

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F9GovV%2FbtrSEfceWw9%2Fbh3jXG3niH0HtgsKeYMs3k%2Fimg.png">

- 프로세스가 시작해서 종료할 때까지 CPU에서 명령을 한꺼번에 수행하면 좋겠지만, 여러 프로세스가 함께 수행되는 시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간 동안 CPU를 사용한 후 빼앗겼다가 추후에 다시 CPU를 획득하는 식으로 CPU 관리가 이루어 진다. CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면 이전의 CPU 보유 시기에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다. 이때 정확한 재현을 위해 필요한 정보가 바로 **프로세스의 문맥** 이다.



### 2. 프로세스의 상태

프로세스의 상태는 실행, 준비, 봉쇄의 세 가지로 구분할 수 있다.

1. 실행
   - 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태
2. 준비
   - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
3. 봉쇄
   - CPU를 할당 받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
   - Ex) 프로세스가 요청한 입출력 작업이 진행 중인 경우

4. 시작
   - 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
5. 종료
   - 프로세스가 종료되었지만 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI8x7L%2FbtrSB3c45mf%2FmPKwHS8f7wfxTKLc1D6vy1%2Fimg.png" />

- 하나의 프로세스는 항상 앞서 설명한 상태 중의 어느 한 상태에 머물러 있게 된다. 그리고 그 상태는 시간이 흐름에 따라 변하게 된다.



### 3. 프로세스 제어블록

프로세스 제어블록(Process Controln Block : PCB) 란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다.

PCB는 다음과 같은 요소들로 구성되어 있다.

- 프로세스의 상태(process state)
  - cpu를 할당해도 되는지 여부를 결정하기 위해 필요
- 프로그램 카운터(program counter) 의 값
  - 다음에 수행할 명령의 위치를 가르킨다.
- CPU 레지스터(CPU register) 의 값
  - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다.
- CPU 스케줄링 정보(CPU scheduling information)
  - 프로세스의 CPU 스케줄링
- 메모리 관리 정보(memory management infomation)
  - 메모리 할당
- 자원 사용 정보(accounting information)
  - 사용자에게 자원 사용 요금을 계산해 청구
- 입출력 상태 정보(I/O status information)
  - 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9a6m0%2FbtrSJnOMxdi%2FKGwBexD1c3asqDRONgOREk%2Fimg.png" />



### 4. 문맥교환

문맥교환(context switch) 이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1oaZa%2FbtrSJxRdiwo%2FlgNuL6uGAkxtp1qoRrV5Rk%2Fimg.png"/>

- 프로세스가 실행 상태일 때 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 운영체제로 넘어와 원래 실행 중이던 프로세스의 업무를 잠시 멈추고 운영체제 커널의 코드가 실행된다. 이 경우에도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하게 되지만 이러한 과정을 문맥교환이라고 하진 않는다.

  이는 하나의 프로세스의 실행모드만이 사용자 모드에서 커널모드로 바뀌는 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다.

- 문맥교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 오버헤드라고 할 수 있다. 이는 문맥교환 중에 일어나는 작업이 실제 시스템에게 유용한 작업이 아니기 때문이다. 따라서 타이머에 CPU 할당시간을 아주 작게 세팅하면 좋지 않다. 그 반대로 CPU의 할당시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색되므로 적절한 할당시간이 필요하다.



### 5. 프로세스를 스케줄링하기 위한 큐

운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다. 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.

- 큐는 하드웨어 자원을 기다리는 큐와 소프트웨어 자원을 기다리는 큐가 있다.
- 하드웨어의 경우 키보드, 디스크, 프린터 등 해당 하드웨어에 입출력 큐가 존재한다.
- 소프트웨어 자원 큐의 경우 예를 들어 공유데이터에 대한 접근 권한은 소프트웨어 자원으로 분류될 수 있다. 어떠한 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손될 수 있다. 따라서 공유데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다. 이때 접근한다는 것이 반드시 CPU가 그 데이터를 사용하고 있음을 의미하는 것은 아니다. 공유 데이터에 접근 중인 프로세스가 준비 상태나 봉쇄 상태로 변경된 경우에도 새롭게 CPU를 할당받은 프로세스가 동일한 데이터에 접근하게 되면 데이터의 일관성이 깨어질 수 있으므로 접근을 허락해서는 안된다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtecWB%2FbtrSKvy603D%2FxCNF9fdjvwlxmWsRlTuKvK%2Fimg.png"/>

- 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행하게 된다. 각 프로세스가 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리한다는 뜻이다. 예를 들어 타이머 인터럽트가 발생하면 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해 다음에 어느 프로세스에게 CPU를 할당할지 결정하고, 현재 실행 중인 프로세스는 준비 큐의 제일 뒤로 보낸다.
- 위 그림은 준비 큐와 다양한 장치 큐를 운영체제가 어떻게 자료구조로 구현하는지 보여준다. 장치 큐는 각각의 자원마다 큐가 하나씩 존재하며, 큐헤더는 큐의 가장 앞부분을 말한다. 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포인터를 사용해 순서를 정한다. 프로세스가 CPU를 할당받고 코드를 수행하다가 입출력 요청이 발생하면 해당 장치 큐에 가서 줄을 서게 된다. 장치 큐에 속한 프로세스들은 봉쇄 상태에 있다가 해당 장치의 서비스를 받고 나서 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 준비 큐로 이동한다.



### 6. 스케줄러

스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다. 스케줄러에는 장기 스케줄러와 단기 스케줄러가 있다. 장기 스케줄러는 작업 스케줄러라고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할을 한다. 준비 큐는 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합이고, CPU 에서 실행되기 위해서는 프로세스가 메모리를 보유해야 하므로, 장기 스케줄러는 프로세스에게 메모리를 할당하는 문제에 관여하게 된다.

- 현대의 시분할 시스템에서 사용하는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnQ0mL%2FbtrSIqFNjgV%2FcnhSzaonnKOXmiDUdpXgh0%2Fimg.png"/>

- 중기 스케줄러가 일부 프로세스를 메모리에서 디스크로 스왑 아웃시켜야 하는 경우 그 0순위인 프로세스는 봉쇄 상태에 있는 프로세스들이다. 이는 봉쇄 상태인 프로세스들의 경우 당장 CPU를 획득할 가능성이 없기 때문이다. 봉쇄 상태인 프로세스를 모두 스왑아웃 시킨 후에도 메모리 공간이 부족한 경우, 보통 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑아웃 시킨다.
- 중기 스케줄러의 등장으로 인해 프로세스의 상태에는 실행, 준비, 봉쇄 외에 하나의 상태가 더 추가된다. 외부적인 이유로 프로세스의 수행이 정지된 상태를 나타내는 중지(suspended, stopped) 상태가 그것이다. 중지상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화 될 수 없으므로 당장 메모리 자원이 필요하지 않다.



### 7. 프로세스의 생성

운영체제가 프로세스 전부를 생성한다고 생각할 수 있지만 사실은 그렇지 않다. 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 이때 프로세스를 생성한 프로세스를 부모 프로세스라고 하고, 새롭게 생성된 프로세스를 자식 프로세스라고 한다.

생성할 때는 fork() 라는 명령을 통해 시스템 콜을 이용해서 운영체제 커널에 프로세스 복제를 맡긴다.

프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행된다.

- 프로세스의 트리를 생성
- 프로세스는 자원을 필요로 함
  - 운영체제로 부터 받는다.
  - 부모와 공유한다.
- 자원의 공유
  - 부모와 자식이 모든 자원을 공유 받는 모델
  - 일부를 공유받는 모델
  - 전혀 공유하지 않는 모델
- 수행
  - 부모와 자식이 공존하며 수행되는 모델
  - 자식이 종료될 때까지 부모는 기다리는 모델
- 주소공간
  - 자식은 부모의 공간을 복사함
  - 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
  - Fork() 시스템콜이 새로운 프로세스를 생성
    - 부모를 그대로 복사(OS data except PID + binary)
    - 주소공간 할당
    - 스택과 프로그램 카운터 등 부모 프로세스를 그대로 복제하기 때문에 어떤 라인까지 수행되었는지 복제 되었는지 까지 알고 있다. 구별할 수 있는 것은 fork() 결과값으로 원본에게는 양수를 주고 복제본에게는 0을 준다는 것
  - fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림
  - 프로세스가 마지막 명령을 수행한 뒤 운영체제에 이것을 알려줌(exit)
    - 자식이 부모에게 output data 를 보냄(via wait)
    - 프로세스의 각종 자원들이 운영체제에 반납됨
  - 부모 프로세스가 자식을 종료시킴(abort)
    - 자식이 할당 자원의 한계치를 넘어섬
    - 자식에게 할당된 테크스가 더이상 필요하지 않음
    - 부모가 종료하는 경우
      - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더이상 수행하지 않도록 한다.
      - 단계적 종료
  - Wait() 라는 함수가 있다. Wait 시스템 콜은 자식 프로세스가 종료되기를 기다리며 부모프로세스가 봉쇄 상태에 머무르도록 할 때 사용된다.



### 8. 프로세스 간의 협력

프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다. 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다. 다른 프로세스와 정보를 주고받을 수 있는 방법이 없기 때문이다.

- 경우에 따라서 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진 될 수 있다.
- 프로세스 간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로는 IPC 가 있다.
  - IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스간에 발생하는 통신을 말한다.
  - 이런 통신에서는 의사소통 기능과 함께 동기화를 보장해 주어야 한다. (공유 데이터를 서로 다른 두 프로세스가 사용한다고 하면 데이터 불일치 문제가 발생할 수 있기 때문이다.)
  - IPC 는 프로세스들 간의 통신과 동기화를 이루기 위한 메커니즘을 의미한다.
  - IPC의 대표적인 방법으로는 메시지 전달 방식과 공유메모리 방식이 있다. 이 두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않은 가에 있다.



- 메시지 전달 방식은 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고 받으면서 통신하는 방식이다. 이때 두 프로세스의 주소공간이 다르므로 메시지 전달을 직접 할 수는 없으며 커널이 그 역할을 하게 된다.

  - 메시지 통신을 하는 시스템은 커널에 의해 send 와 receive 라는 두가지 연산을 제공 받는다.
  - 메시지를 프로세스끼리 직접 주고 받을 수 있다면 원하지 않는 메시지를 전달해 다른 프로세스에 악영향을 미칠 수 있으므로 운영체제는 메시지를 주고 받는 연산을 특권명령으로 규정해 커널을 통해서만 가능하도록 하고 있다.

- 메시지 전달을 통해 통신하는 방식은 메시지의 전송 대상이 다른 프로세스인지 아니면 메일박스라는 일종의 저장공간인지에 따라 다시 직접 통신과 간접통신으로 나뉜다. 두가지 방식의 차이는 연산의 인터페이스에 대한 차이일뿐 실제 메시지 전송이 이루어지는 내부 구현은 커널의 중재에 의해 사실상 동일한 방식으로 이루어진다.

  1. 직접통신
     - 프로세스 이름을 명시
     - 하나의 링크는 정확히 한쌍의 프로세스에게 할당
     - 단방향성일 수 있으나 대부분의 경우 양방향성
  2. 간접통신
     - 메일박스 또는 포트로부터 전달받는다.
     - 메일박스는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신을 할 수 있다.
     - 하나의 링크가 여러 프로세스들에게 할당 가능, 각 프로세스의 쌍은 여러 링크를 공유할 수 있다.
     - 링크는 단방향성 또는 양방향성일 수 있다.
     - P1, P2, P3 가 메일박스 A를 공유하는 경우 P1이 메시지를 보냈다면 P2 와 P3 중 어느 프로세스가 메시지를 받는가?
       - 2개의 프로세스에게만 링크를 할당하는 방법을 사용
       - 즉 P2 와 P3 에게 각각 따로 링크를 생성하는 것이다.
       - 또는 링크에 대한 receive() 연산을 매 시점 하나의 프로세스만 수행할 수 있도록 하는 방법이 있다.
       - 그렇지 않다면 시스템이 메시지 수신자를 임의로 결정해 누가 메시지를 받았는지 송신자에게 통신해주는 방식을 사용할 수 있다.

  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGzcWQ%2FbtrSLKcyDTa%2FsVgcbhCjrEWpJIgSC2zTZk%2Fimg.png"/>



- 공유 메모리 방식은 프로세스들이 주소 공간 일부를 공유한다.
  - 원칙적으로 서로 다른 프로세스는 각자 독립적인 주소 공간을 가지므로 프로세스 A가 자신의 주소 공간에 특정한 내용을 쓸 경우 이는 자신만 볼 수 있다.
  - 운영체제는 공유메모리를 사용하는 시스템 콜을 지원해, 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유 할 수 있도록 한다.
  - 공유메모리 영역은 각자의 주소 공간에 공통적으로 포함되는 영역이므로 여러 프로세스가 읽고 쓰는 것이 가능하다.
  - 실제 구현은 프로세스 A 와 B가 독자적인 주소 공간을 가지고 있지만, 이 주소공간이 물리적 메모리에 매핑될 때 공유 메모리 주소영역에 대해서는 동일한 물리적 메모리 주소로 매핑되는 것이다.
  - 서로의 데이터에 일관성 문제가 있을 수 있다. 이는 커널이 책임지지 않기 때문에 프로세스들 끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 한다.



<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcF7woT%2FbtrSJSIVWor%2FaTFtobrfExomFVj2emkeyK%2Fimg.png" />
