# 단일 책임 원칙



소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다. SRP가 말하는 '변경의 이유'란 바로 이들 사용자와 이해관계자를 가리킨다.



> 단일 책임 원칙이란
> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.



- 응집된 이라는 단어가 단일책임원칙을 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.
- 이 원칙을 위반하는 사례를 살펴보고 이 원칙을 이해해보자



### 우발적 중복



Employee 클래스가 있다고 가정하고 이 클래스는 세 가지 메서드 calculagePay(), reportHoures(), save()를 가진다. 이 클래스는 SRP를 위반하는데 이들 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문이다.



-  calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고 CTO 보고를 위해 사용한다.



개발자가 이 세 메서드를 Employee 라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다. 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수 있다.



- 예를 들어 calculagePay() 메서드와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메서드에 넣었다고 해보자
- 그런데 이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 COO 팀에서는 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.
- 이 변경을 적용하는 업무를 할당받은 개발자는 calculagePay() 메서드가 편의 메서드인 regularHours()를 호출한다는 사실을 발견한다. 하지만 안타깝게도 이 함수가 reportHours() 메서드에서도 호출된다는 사실은 눈치채지 못한다.
- 개발자는 요청된 변경사항을 적용하고 신중하게 테스트하낟. CFO 팀은 새로운 메서드가 원하는 방식으로 동작하는지 검증하고, 시스템을 배포하지만 COO 팀에서는 이러한 일이 벌어지고 있다는 사실을 알지 못한다.
- COO 팀 직원은 reportHours() 메서드가 생성한 보고서를 여전히 이용한다. 하지만 이제 이 보고서에 포함된 수치는 엉망이고 잘못된 데이터로 수백만 달러의 예산이 지출되었다.....



우리는 이와 같은 상황이 벌어질 수 있다. 이러한 문제는 서로 다른액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다. SRP는 서로 다른액터가 의존하는 코드를 서로 분리하라고 말한다.



### 병합

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다. 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.



⚡ 예를 들어 DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 약간 수정하기로 결정했다고 해보자. 이와 동시에 인사 담당자가 속한 COO 팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 결정했다고 해보자.

- 서로 다른 개발자가 그리고 아마도 서로 다른팀에 속했을 두 개발자가 Employee 클래스를 체크아웃받은 후 변경사항을 적용하기 시작한다. 안타깝게도 이들 변경사항은 서로 충돌한다. 결과적으로 병합이 발생한다.
- 병합에는 위험이 따른다고 굳이 말하지 않아도 될 것이다. 최근 도구는 굉장히 뛰어나지만, 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수는 없다. 결국 병합에는 항상 위험이 뒤따르게 된다.
- 많은 사람들이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우 문제가 생길 위험이 많다. 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.



#### 해결책

이 문제의 해결책은 다양한데,  그 모두가 메서드를 각기 다른클래스로 이동시키는 방식이다. 아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다. 

- 즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 한다. 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다. 세 클래스는 서로의 존재를 몰라야 한다. 따라서 우연한 중복을 피할 수 있다.
- 반면 이 해결책은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 이런 난관에서 빠져나올 때 흔히 쓰는 기법으로 퍼사드 패턴이 있다.

```java
// 퍼사드 패턴
// ftp, reader, writer 가 있을때 각각의 프로세스를 순서대로 실행해야 파일을 주고 받을 수 있지만
// 이 과정을 한군데에서 진행하면 효과적으로 관리할 수 있다.

public class Ftp {

    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }

    public void connect() {
        System.out.println("FTP Host : " + host + " Port : " + port + "로 연결합니다.");
    }

    public void moveDirectory() {
        System.out.println("path : " + path + " 로 이동합니다.");
    }

    public void disConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}


public class Reader {

    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s 로 연결합니다.", fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s 의 내용을 읽어 옵니다.", fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s 로 연결종료 합니다.", fileName);
        System.out.println(msg);
    }
}


public class Writer {

    private String fileName;

    public Writer(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Writer %s 로 연결합니다.", fileName);
        System.out.println(msg);
    }

    public void write() {
        String msg = String.format("Writer %s 로 파일 쓰기를 합니다.", fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Writer %s 로 연결 종료합니다.", fileName);
        System.out.println(msg);
    }
}

public class SftpClient {

    private Ftp ftp;
    private Writer writer;
    private Reader reader;

    public SftpClient(Ftp ftp, Writer writer, Reader reader) {
        this.ftp = ftp;
        this.writer = writer;
        this.reader = reader;
    }

    public SftpClient(String host, int port, String path, String fileName) {
        this.ftp = new Ftp(host, port, path);
        this.writer = new Writer(fileName);
        this.reader = new Reader(fileName);
    }

    public void connect() {
        ftp.connect();
        ftp.moveDirectory();
        writer.fileConnect();
        reader.fileConnect();
    }

    public void disconnect() {
        reader.fileDisconnect();
        writer.fileDisconnect();
        ftp.disConnect();
    }

    public void read() {
        reader.fileRead();
    }

    public void write() {
        writer.write();
    }
}



public class Facade {

    public static void main(String[] args) {
        Ftp ftp = new Ftp("www.foo.co.kr", 22, "/home/etc");

        ftp.connect();
        ftp.moveDirectory();

        Writer writer = new Writer("text.tmp");

        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileConnect();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftp.disConnect();

        SftpClient sftpClient = new SftpClient("www.foo.co.kr", 22, "/home/etc", 														"text.tmp");
        sftpClient.connect();
        sftpClient.write();
        sftpClient.read();
        sftpClient.disconnect();
    }
}

```

⭐ SftpClient에 코드는 거의 없다. 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.



- 어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다. 이 경우라면 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.
- 모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 근거하여 앞의 해결책에 반대할 수도 있다. 하지만 이 주장은 현실과는 전혀 다르다. 각 클래스에서 지불, 보고서 생성, 데이터 저장 기능을 구현하는 데 필요한 메서드의 개수는 실제로 훨씬 더 많을 것이다. 이들 클래스는 모두 다수의 private 메서드를 포함할 것이다. 이 처럼 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구가 있는지를 전혀 알 수 없다.



### 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 패쇄 원칙이 된다. 아키텍쳐 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다. 이러한 개념들에 대해서는 나중에 살펴보자.