# 부분적 경계



아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. 많은 경우에, 뛰어난 아키텍트라면 이러한 경계를 만드는 비용이 너무 크다고 판단하면서도, 한편으로는 나중에 필요할 수도 있으므로 이러한 경계에 필요한 공간을 확보하기 원할 수도 있다.



### 마지막 단계를 건너뛰기

부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.

- 이처럼 부분적 경계를 만들려면 완벽한 경계를 만들 때 만큼의 코드량ㅁ과 사전 설계가 필요하다. 하지만 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다. 
- 이는 FitNesse를 뒷받침했던 초기 전략이었다. FitNesse의 웹 서버 컴포넌트는 FitNesse 의 위키나 테스트 영역과는 분리되도록 설계되었다. 새로운 웹 기반 애플리케이션을 만들 때 해당 웹 컴포넌트를 재사용할 수도 있다고 생각했기 때문이었다.
- 이처럼 컴포넌트를 두 개로 분리했지만, 사용자가 두 번 다운로드하도록 만들고 싶지는 않았다. 우리의 설계 목표 중 하나가 "다운로드 후 바로 실행" 이었다는 점을 상기하자. 우리는 사용자가 하나의 jar 파일을 다운로드하면, 또 다른 jar 파일을 찾아다니거나 버전 호환성을 해결하는 등의 작업을 하지 않고도 실행할 수 있게 만들고자 했다.
- FitNesse 이야기는 마지막 단계를 건너뛰는 이 접근법이 지닌 위험 역시 지적하고 있다. 시간이 흐르면서, 별도로 분리한 웹 컴포넌트가 재사용될 가능성은 전혀 없을 것임이 명백해지고, 웹 컴포넌트와 위키 컴포넌트 사이의 구분도 약화되기 시작했다. 의존성은 잘못된 방향으로 선을 넘기 시작했다. 이 둘을 다시 분리하는 작업은 따분한 일이 될 것이다.



### 일차원 경계

완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.

- 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 더 간단한 구조가 있다. 이는 전통적인 전략 패턴을 사용한 전형적인 사례다. ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceImpl 클래스가 구현한다.
- 이 방식이 미래에 필요할 아키텍처 경계를 위한 무대를 마련한다는 점은 명백하다. Client를 ServiceImpl로부터 격리시키는 데 필요한 의존성 역전이 이미 적용되었기 때문이다.
- 또한 이 다이어그램의 위험천만한 점선 화살표에서 보듯이 이런한 분리는 매우 빠르게 붕괴될 수 있다는 점 역시 분명하다. 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다며, 이 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다.



### 퍼사드

이보다 훨씬 더 단순한 경계는 퍼사드 패턴으로 이 경우에는 심지어 의존성 역전까지도 희생한다. 경계는 Facade 클래스로만 간단히 정의한다. Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.



```java
// 퍼사드 패턴

public class Facade {

    public static void main(String[] args) {
        Ftp ftp = new Ftp("www.foo.co.kr", 22, "/home/etc");

        ftp.connect();
        ftp.moveDirectory();

        Writer writer = new Writer("text.tmp");

        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileConnect();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftp.disConnect();

        SftpClient sftpClient = new SftpClient("www.foo.co.kr", 22, "/home/etc", "text.tmp");
        sftpClient.connect();
        sftpClient.write();
        sftpClient.read();
        sftpClient.disconnect();
    }
}

public class Ftp {

    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }

    public void connect() {
        System.out.println("FTP Host : " + host + " Port : " + port + "로 연결합니다.");
    }

    public void moveDirectory() {
        System.out.println("path : " + path + " 로 이동합니다.");
    }

    public void disConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

public class SftpClient {

    private Ftp ftp;
    private Writer writer;
    private Reader reader;

    public SftpClient(Ftp ftp, Writer writer, Reader reader) {
        this.ftp = ftp;
        this.writer = writer;
        this.reader = reader;
    }

    public SftpClient(String host, int port, String path, String fileName) {
        this.ftp = new Ftp(host, port, path);
        this.writer = new Writer(fileName);
        this.reader = new Reader(fileName);
    }

    public void connect() {
        ftp.connect();
        ftp.moveDirectory();
        writer.fileConnect();
        reader.fileConnect();
    }

    public void disconnect() {
        reader.fileDisconnect();
        writer.fileDisconnect();
        ftp.disConnect();
    }

    public void read() {
        reader.fileRead();
    }

    public void write() {
        writer.write();
    }
}

public class Reader {

    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s 로 연결합니다.", fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s 의 내용을 읽어 옵니다.", fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s 로 연결종료 합니다.", fileName);
        System.out.println(msg);
    }
}

public class Writer {

    private String fileName;

    public Writer(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Writer %s 로 연결합니다.", fileName);
        System.out.println(msg);
    }

    public void write() {
        String msg = String.format("Writer %s 로 파일 쓰기를 합니다.", fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Writer %s 로 연결 종료합니다.", fileName);
        System.out.println(msg);
    }
}

```



- 하지만 Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된 것을 주목하자. 정적 언어였다면 서비스 클래스 중 하나에서 소스 코드가 변경되면 Client도 무조건 재컴파일해야 할 것이다. 이러한 구조라면 비밀 통로 또한 정말 쉽게 만들 수 있다는 사실도 충분히 파악할 수 있을 것이다.



### 결론

아키텍처 경계를 부분적으로 구현하는 간단한 방법 세 가지를 살펴봤다. 물론 이 외에도 방법은 많다. 세 전략은 순전히 예로써 제시했다.



- 이러한 접근법 각각은 나름의 비용과 장점을 지닌다. 각 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다르다. 또한 각 접근법은 해당 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.
- 아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 경정하는 일 또한 아키텍트의 역할이다.