# 컴포넌트 결합



지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다. 이 장에서도 마찬가지로 개발 가능서오가 논리적 설계 사이의 균형을 다룬다. 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.



### ADP: 의존성 비순환 원칙



> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.



하루 종일 일해서 무언가를 작동하게 만들어 놓고 퇴근했는데, 이튿날 출근해 보면 전혀 돌아가지 않는 경험을 해본 적이 있지 않은가? 왜 작동하지 않게 되었나? 왜냐하면 누군가 당신보다 더 늦게까지 일하면서 당신이 의존하고 있던 무언가를 수정했기 때문이다. 나는 이러한 현상을 '숙취 증후군' 이라 부른다.



- 소수의 개발자로 구성된 상대적으로 작은 프로젝트에서는 이 증후군이 그다지 큰 문제가 되지 않는다. 하지만 프로젝트와 개발팀 규모가 커지면 숙취는 지독한 악몽이 될 수도 있다. 
- 지난 수십 년 동안 이 문제의 해결책으로 두 가지 방법이 발전되어 왔는데, 이 두 해결책은 모두 통신 업계에서 만들어졌다. 첫 해결책은 '주 단위 빌드' 이며, 두 번째 해결책은 '의존성 비순환 원칙' 이다.



#### 주 단위 빌드

주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다. 주 단위 빌드를 하는 방법은 다음과 같다. 

1. 먼저 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경 쓰지 않는다. 개발자는 모두 코드를 개인적으로 복사하여 작업하며, 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않는다. 
2. 그런 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.



이 접근법은 5일 중 4일 동안 개발자를 고립된 세계에서 살 수 있게 보장해 준다는 아주 멋진 장점을 가진다. 물론 단점은 금요일에 통합과 관련된 막대한 업보를 치러야 한다는 사실이다.

- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 하루 만에 마치는게 불가능해진다.
- 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 나빠진다. 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.



#### 순환 의존성 제거하기

이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다. 

1. 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.
2. 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다. 
3. 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자는 릴리스된 버전을 사용한다.



컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다. 적용하지 않기로 했다면 그냥 과거 버전의 릴리스를 계속 사용한다. 새 릴리스를 적용할 준비가 되었다는 판단이 들면 새 릴리스를 사용하기 시작한다.



- 따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다. 특정 컴포넌트가 변경 되더라도 다른 팀에 즉각 영향을 주지 않는다. 각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.
- 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다는 사실이다. 이 구조에는 순환이 없다.
- 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.



#### 순환이 컴포넌트 의존성 그래프에 미치는 영향

새로운 요구사항이 발생해서 순환 의존성이 생기게 된다면 즉각적인 문제를 일으키게 된다. 이렇게 순환 의존성이 되면 상향식으로 릴리스 하기가 훨씬 어려워 진다. 사실상 하나의 거대한 컴포넌트가 되기 때문이다.

- 이들 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 거라는 의미다.
- 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다. 단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다. 게다가 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.
- 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다. 사실 순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다. 특히 자바와 같이 컴파일된 바이너리 파일에서 선언문을 읽어 들이는 언어라면 끔찍한 문제가 일어날 수도 있다.



#### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 원상복구하는 일은 언제라도 가능하다. 이를 위한 주요 메커니즘 두 가지를 살펴보자.



1. 의존성 역전 원칙을 적용한다. 메서드를 제공하는 인터페이스를 생성하고 그 인터페이스를 사용하는 쪽 컴포넌트에 위치시킨다. 그리고 그 인터페이스를 구현하는 구현체는 다른 컴포넌트에 위치시켜 의존성을 역전시킨다. 이렇게 하면 순환을 끊을 수 있다.
2. 모두가 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.



#### 흐트러짐

두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다. 

- 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. **따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.** 순환이 발생하면 어떤 식으로든 끊어야 한다.
- 이 말은 때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있음을 의미한다.



### 하향식 설계

지금까지 논의로 우리는 피할 수 없는 결론에 다다르게 된다. 즉 컴포넌트 구조는 하향식으로 설계될 수 없다.

컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 진화한다. 우리는 컴포넌트와 같이 큰 단위로 분해된 구조는 고수준의 기능적인 구조로 다시 분해할 수 있다고 기대하기 때문이다.

- 컴포넌트 의존성 구조와 같이 큰 단위로 분해된 집단을 관찰하면 시스템의 기능적 측면을 컴포넌트가 어떤 식으로든 표현하리라고 믿는다. 하지만 이는 컴포넌트 의존성 다이어그램이 가진 속성으로 보이지는 않는다.
- 사실 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다. 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다. **빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.**
- 모듈이 점점 쌓이기 시작하면, '숙취 증후군'을 겪지 않고 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점차 늘어나게 된다. 뿐만 아니라 변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다.



⭐ 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다. 우리는 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해, 그렇지 않았다면 안정적이었을 컴포넌트가 영향받는 일을 원치 않는다.



🚀 애플리케이션이 계속 성장함에 따라 우리는 재사용 가능한 요소를 만드는 일에 관심을 기울이기 시작한다. 이 시점이 되면 컴포넌트를 조합하는 과정에 공통 재사용 원칙이 영향을 미치기 시작한다. 결국 순환이 발생하면 ADP 가 적용되고, 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.



> 결국 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.



### SDP: 안정된 의존성 원칙



> 안정성의 방향으로(더 안정된 쪽에) 의존하라.



설계는 결코 정적일 수 없다. 설계를 유지하다 보면 변경은 불가피하다. 공통 폐쇄 원칙을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.

- 이처럼 컴포넌트 중 일부는 변동성을 지니도록 설계된다. 우리는 변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라고 예상한다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.
- 이는 소프트웨어가 가진 괴팍함이다. 즉 당신이 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.



#### 안정성

무언가가 안정적이라는 말을 웹스터 사전에서는 '쉽게 움직이지 않는' 이라고 정의한다. 안정성은 변경을 만드릭 위해 필요한 작업량과 관련된다. 



- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인이 존재하며, 그 예로는 컴포넌트의 크기, 복잡도, 간결함 등을 들 수 있다.
- 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.



### 장치독립성

예전 프로그래밍을 할때 많은 실수를 저질렀었다. 대표적인 실수 중 하나는 코드를 입출력 장치와 직접 결합해버린 일이었다. 프린터로 인쇄할 일이 있다면, 해당 프린터를 제어하는 입출력 명령어를 직접 사용해서 코드를 작성했다. 이러한 코드는 장치 종속적이었다.

- 장치에 종속적이면 장치가 변경된다면 많은 변경 포인트가 생기게 되기 때문에 장치 독립성에 대해 생각해 내기 시작했다. 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 단위 레코드를 처리한다.
- 이제는 동일한 프로그램을 아무런 변경 없이도 카드에서 일고 쓰거나 테이프에서 읽고 쓸 수 있게 되었다. 개방 폐쇄 원칙이 탄생한 순간이다.



### 결론

이 장에 포함된 사례는 소규모 사례이지만, 그 원칙은 아키텍트가 대규모 시스템에 적용할 수 있는 예이기도 하다. 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 좋은 아키텍트는 세부사항에 대한 결정을 가능한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.